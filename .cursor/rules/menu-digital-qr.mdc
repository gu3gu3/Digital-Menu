---
description: 
globs: 
alwaysApply: true
---
# Principios y Reglas Fundamentales del Proyecto Digital Menu QR

## 1. La Infraestructura es Inmutable y Automatizada
El sistema de despliegue (Dockerfile, cloudbuild.yaml, start.sh) es estable y no debe tocarse a menos que sea estrictamente necesario y se haya probado.

**Regla 1.1: El Despliegue es Sagrado.** La única forma de actualizar producción es con git push a la rama main.

**Regla 1.2: El Dockerfile es el Plano.** Cualquier dependencia del sistema (como netcat-openbsd) debe estar en el Dockerfile.

**Regla 1.3: La Versión de Node.js es Única.** La versión de Node.js debe ser la misma en el Dockerfile y en cloudbuild.yaml para evitar fallos de build.

## 2. El Código es Agnóstico al Entorno (Cero "Hardcoding")
El código no debe contener valores fijos que cambien entre tu máquina y la nube.

**Regla 2.1: Toda Configuración es Externa.** URLs, puertos y claves secretas se leen siempre desde variables de entorno.

**Regla 2.2: .env es para Desarrollo Local.** Contiene las variables para que todo funcione en tu computadora y está en .gitignore.

**Regla 2.3: Las Variables de Cloud Run son para Producción.** Son el panel de control para la nube. Las variables clave son:
- DATABASE_URL
- JWT_SECRET (el único secreto para todos los tokens)
- BACKEND_URL (la URL pública del backend, ej: https://...run.app)
- VITE_FRONTEND_URL (la URL pública del frontend, ej: https://menuview.app)
- EMAIL_USER, EMAIL_PASSWORD, EMAIL_HOST, EMAIL_PORT
- NODE_ENV
- GCP_STORAGE_BUCKET

## 3. Fronteras Claras entre Frontend y Backend
Cada parte tiene una única responsabilidad.

**Regla 3.1: El Backend Construye URLs de sus Recursos.** Para las imágenes, el backend usa su BACKEND_URL para crear la ruta completa: `${process.env.BACKEND_URL}/uploads/imagen.jpg`.

**Regla 3.2: El Frontend Construye URLs de Navegación.** Para compartir un menú, el frontend usa su VITE_FRONTEND_URL para crear el enlace: `${import.meta.env.VITE_FRONTEND_URL}/menu/nombre-restaurant`.

## 4. Configuración Limpia y Consistente

**Regla 4.1: Eliminar Variables Obsoletas.** Si una variable en el archivo .env no se usa en el código (como JWT_SECRET_SUPERADMIN), debe ser eliminada para evitar confusiones.

## 5. Diagnóstico Primero, Acción Después

**Regla 5.1: Los Logs son la Verdad.** Ante un error 500 en producción, el primer paso es siempre revisar los logs de Cloud Run. No se deben hacer cambios en el código sin saber qué está fallando.

---

## 6. ⭐ ARQUITECTURA API CONSOLIDADA (Post-Refactorización 2024)

### Cliente API Unificado
**Regla 6.1: Un Solo Cliente API.** Todo el frontend debe usar `apiClient.js` (packages/frontend/src/lib/apiClient.js). NUNCA usar fetch directo o múltiples clientes.

**Regla 6.2: Interceptores Automáticos.** El apiClient maneja automáticamente tokens, errores y configuración. No manejar tokens manualmente en componentes.

**Regla 6.3: Estructura de Respuesta Consistente.** Todas las APIs deben seguir el patrón axios: `response.data` contiene la respuesta, `error.response.data.error` contiene errores.

### Gestión de Autenticación
**Regla 6.4: TOKEN_MAPPING es la Verdad.** Los tipos de usuario y sus tokens están definidos en authService.js:
```javascript
{
  'MESERO': { tokenKey: 'staffToken', userKey: 'staffUser' },
  'ADMINISTRADOR': { tokenKey: 'adminToken', userKey: 'adminUser' },
  'SUPER_ADMIN': { tokenKey: 'superAdminToken', userKey: 'superAdminUser' }
}
```

**Regla 6.5: Roles Backend vs Frontend.** El backend espera 'ADMINISTRADOR' y 'MESERO', no 'ADMIN' o 'STAFF'. Usar los valores exactos del TOKEN_MAPPING.

**Regla 6.6: Interceptores Buscan Tokens en Orden.** El apiClient busca automáticamente: superAdminToken → adminToken → staffToken. No especificar tokens manualmente.

### Servicios Consolidados
**Regla 6.7: Un Servicio por Dominio.** Cada área funcional tiene un servicio dedicado:
- authService.js: Autenticación universal
- staffService.js: Gestión de personal  
- menuService.js: Gestión de menú
- restaurantService.js: Configuración de restaurante
- superAdminService.js: Panel de super admin
- ordersService.js: Gestión de órdenes
- notificationService.js: Sistema de notificaciones
- sessionsService.js: Sesiones de mesa

**Regla 6.8: Servicios Usan apiClient.** TODOS los servicios deben importar y usar apiClient, nunca fetch directo.

**Regla 6.9: Manejo de Errores Consistente.** Usar `error.response?.data?.error || 'Mensaje fallback'` para extraer errores de axios.

### Patrones de Importación
**Regla 6.10: Importaciones Correctas.**
```javascript
// ✅ CORRECTO
import apiClient from '../lib/apiClient'
import authService from '../services/authService'

// ❌ INCORRECTO
import { authService } from '../services/authService'
import adminApi from '../lib/adminApi'
```

**Regla 6.11: Rutas Relativas Consistentes.** Usar rutas sin `/api` en servicios: `apiClient.get('/categories')` no `apiClient.get('/api/categories')`.

## 7. Prevención de Deriva de Código

**Regla 7.1: No Múltiples Clientes API.** Si encuentras fetch directo, adminApi, o múltiples patrones de API, es deriva de código. Consolidar inmediatamente.

**Regla 7.2: Testing Durante Refactor.** Validar que los 3 tipos de login funcionan después de cualquier cambio en autenticación.

**Regla 7.3: Migración Gradual.** Cambios arquitecturales deben hacerse por fases, validando cada fase antes de continuar.

**Regla 7.4: Documentar Cambios Arquitecturales.** Actualizar PROJECT-STATUS.md con cualquier refactorización significativa.

**Regla 7.5: Separación Pública vs Autenticada.** Los componentes públicos (OrderTracker, DemoSection) PUEDEN usar fetch directo porque no requieren autenticación. Solo migrar componentes que manejan tokens.

**Regla 7.6: Validación Continua Durante Migración.** Después de cada cambio arquitectural, validar que los 3 tipos de login (Super Admin, Admin, Staff) siguen funcionando.

**Regla 7.7: Endpoint Consistency Check.** Antes de migrar, verificar que el endpoint existe en el backend. Usar `/me` en lugar de `/profile` para obtener datos del usuario actual.

**Regla 7.8: React Keys en Listas.** Todos los elementos mapeados deben tener keys únicas. Usar `key={item.id || `fallback-${index}`}` para evitar warnings.

---

## Análisis Detallado de Rutas y Lógica Clave

### 1. Backend: Rutas de la API (packages/backend/src/routes/)

**Autenticación:**
- `auth.js`: Login/registro de administradores de restaurantes (/api/auth/login)
- `superAdminAuth.js`: Login del superadministrador (/api/superadmin/auth/login)
- `staff.js`: Gestión del personal y autenticación de meseros

**Gestión del Restaurante (Panel de Administrador):**
- `restaurants.js`: CRUD para información del restaurante
- `products.js`: CRUD para productos del menú
- `categories.js`: CRUD para categorías del menú
- `tables.js`: CRUD para mesas y generación de QR
- `orders.js`: Recepción y gestión de pedidos

**Gestión Global (Panel de Superadministrador):**
- `superAdminSubscriptions.js`: Manejo de suscripciones de restaurantes
- `admin.js`: Gestión de administradores de restaurantes

**Rutas Públicas:**
- `public.js`: Endpoints públicos para visualización de menú
- `cart.js`: Lógica del carrito de compras para clientes

### 2. Frontend: Vistas y Flujo del Usuario (packages/frontend/src/pages/)

**Paneles de Control (Dashboards):**
- `AdminDashboard.jsx`: Panel principal del dueño del restaurante
- `SuperAdminDashboard.jsx`: Panel principal del superadministrador
- `StaffDashboard.jsx`: Panel para personal del restaurante

**Páginas de Login (Puntos de Entrada):**
- `AdminLoginPage.jsx`: Login para administradores de restaurantes
- `SuperAdminLoginPage.jsx`: Login para superadministrador
- `StaffLoginPage.jsx`: Login para personal

**Gestión del Menú (Administrador):**
- `AdminMenuPage.jsx`: Gestión completa de productos y categorías
- `AdminSettingsPage.jsx`: Configuración de perfil y restaurante

**Vista Pública del Menú:**
- `PublicMenuPage.jsx`: Vista pública cuando se escanea QR

**Gestión de Superadministrador:**
- `SubscriptionsListPage.jsx`: Gestión de todas las suscripciones
- `PlansManagementPage.jsx`: Creación y edición de planes de suscripción

### 3. Servicios Frontend Consolidados (packages/frontend/src/services/)

**Core Services:**
- `authService.js`: Autenticación universal con TOKEN_MAPPING
- `apiClient.js`: Cliente HTTP unificado con interceptores automáticos

**Domain Services:**
- `staffService.js`: Gestión de personal
- `menuService.js`: Operaciones de menú (público y autenticado)
- `restaurantService.js`: Configuración de restaurante
- `superAdminService.js`: Operaciones de super admin
- `ordersService.js`: Gestión de órdenes
- `notificationService.js`: Sistema de notificaciones
- `sessionsService.js`: Sesiones de mesa

**Regla de Oro:** Si necesitas comunicarte con el backend, usa un servicio existente o crea uno nuevo siguiendo los patrones consolidados. NUNCA uses fetch directo en componentes.

## 8. ⭐ PATRONES DE MIGRACIÓN CONSOLIDADOS (Post-Fase 5)

### Identificación de Código a Migrar
**Regla 8.1: Detectar Fetch Directo.** Buscar `fetch('/api/` en componentes autenticados. Los públicos son correctos.

**Regla 8.2: Detectar Tokens Manuales.** Buscar `localStorage.getItem('*Token')` en componentes - debe eliminarse.

**Regla 8.3: Detectar Headers Manuales.** Buscar `'Authorization': 'Bearer'` - los interceptores lo manejan automáticamente.

### Patrones de Migración
**Regla 8.4: Migración de GET Simple.**
```javascript
// ❌ ANTES
const token = localStorage.getItem('adminToken')
const response = await fetch('/api/endpoint', {
  headers: { 'Authorization': `Bearer ${token}` }
})
const data = await response.json()

// ✅ DESPUÉS  
const response = await apiClient.get('/endpoint')
const data = response.data
```

**Regla 8.5: Migración de POST con FormData.**
```javascript
// ❌ ANTES
const formData = new FormData()
const response = await fetch('/api/upload', {
  method: 'POST',
  headers: { 'Authorization': `Bearer ${token}` },
  body: formData
})

// ✅ DESPUÉS
const response = await apiClient.post('/upload', formData, {
  headers: { 'Content-Type': 'multipart/form-data' }
})
```

**Regla 8.6: Migración de Manejo de Errores.**
```javascript
// ❌ ANTES
if (response.ok) {
  // éxito
} else {
  const error = await response.json()
  console.error(error.message)
}

// ✅ DESPUÉS
try {
  const response = await apiClient.post('/endpoint', data)
  // éxito automático
} catch (error) {
  console.error(error.response?.data?.error || 'Error fallback')
}
```

### Casos Especiales
**Regla 8.7: Blob Downloads.** Para descargas de archivos, usar `responseType: 'blob'` en apiClient.

**Regla 8.8: Fallback de localStorage.** En componentes de configuración, usar datos de localStorage como fallback si la API falla.

**Regla 8.9: Endpoints Correctos.** Super Admin usa `/super-admin/auth/me`, no `/profile`. Verificar rutas en backend antes de migrar.